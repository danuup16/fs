if game.PlaceId == 121864768012064 then ---ikan
local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/danuup16/mnbru/refs/heads/main/mnu"))()
local HttpService = game:GetService("HttpService")
local AutoConfig = {} do
    AutoConfig.FolderName = "DJSTest"
    AutoConfig.ConfigFile = "DJSikan.json"
    AutoConfig.Library = nil
    AutoConfig.LastSaveTime = 0
    AutoConfig.IsMonitoring = false
    AutoConfig.Parsers = {
        Toggle = {
            Save = function(idx, option) 
                return { type = "Toggle", idx = idx, value = option.Value } 
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, option)
                return { type = "Slider", idx = idx, value = tonumber(option.Value) }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, option)
                return { type = "Dropdown", idx = idx, value = option.Value, multi = option.Multi }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Colorpicker = {
            Save = function(idx, option)
                return { type = "Colorpicker", idx = idx, value = option.Value:ToHex(), transparency = option.Transparency }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
                end
            end,
        },
        Input = {
            Save = function(idx, option)
                return { type = "Input", idx = idx, text = option.Value }
            end,
            Load = function(idx, data, options)
                if options[idx] and type(data.text) == "string" then
                    options[idx]:SetValue(data.text)
                end
            end,
        },
    }
    
    function AutoConfig:Initialize(library)
        self.Library = library
        self:CreateFolders()
        wait(2) 
        self:LoadConfig()
        self:StartChangeMonitoring()
    end
    
    function AutoConfig:CreateFolders()
        if not isfolder(self.FolderName) then
            makefolder(self.FolderName)
        end
    end
    
    function AutoConfig:GetFilePath()
        return self.FolderName .. "/" .. self.ConfigFile
    end
    
    function AutoConfig:SaveConfig()
        local data = { objects = {} }
        
        for idx, option in pairs(self.Library.Options) do
            local parser = self.Parsers[option.Type]
            if parser then
                table.insert(data.objects, parser.Save(idx, option))
            end
        end
        
        local success, encoded = pcall(HttpService.JSONEncode, HttpService, data)
        if success then
            writefile(self:GetFilePath(), encoded)
            self.LastSaveTime = tick()
            return true, "Config saved successfully"
        else
            return false, "Failed to encode config data"
        end
    end
    
    function AutoConfig:LoadConfig()
        local filePath = self:GetFilePath()
        
        if not isfile(filePath) then
            return false, "No config file found"
        end
        
        local success, decoded = pcall(HttpService.JSONDecode, HttpService, readfile(filePath))
        if not success then
            return false, "Failed to decode config"
        end
        
        for _, item in pairs(decoded.objects) do
            local parser = self.Parsers[item.type]
            if parser then
                spawn(function()
                    parser.Load(item.idx, item, self.Library.Options)
                end)
            end
        end
        return true, "Config loaded successfully"
    end
    function AutoConfig:StartChangeMonitoring()
        if self.IsMonitoring then return end
        self.IsMonitoring = true
        local lastValues = {}
        for idx, option in pairs(self.Library.Options) do
            lastValues[idx] = self:GetOptionValue(option)
        end
        
        spawn(function()
            while self.IsMonitoring do
                wait(0.5)
                
                local hasChanges = false
                for idx, option in pairs(self.Library.Options) do
                    local currentValue = self:GetOptionValue(option)
                    if self:ValuesAreDifferent(lastValues[idx], currentValue) then
                        lastValues[idx] = currentValue
                        hasChanges = true
                    end
                end
                
                if hasChanges then
                    local success, msg = self:SaveConfig()
                end
            end
        end)
    end
    function AutoConfig:GetOptionValue(option)
        if option.Type == "Toggle" then
            return option.Value
        elseif option.Type == "Slider" then
            return option.Value
        elseif option.Type == "Dropdown" then
            return option.Value
        elseif option.Type == "Input" then
            return option.Value
        elseif option.Type == "Colorpicker" then
            return {option.Value:ToHex(), option.Transparency}
        end
        return nil
    end
    function AutoConfig:ValuesAreDifferent(oldValue, newValue)
        if type(oldValue) ~= type(newValue) then
            return true
        end
        if type(oldValue) == "table" then
            if #oldValue ~= #newValue then return true end
            for i = 1, #oldValue do
                if oldValue[i] ~= newValue[i] then return true end
            end
            return false
        end
        
        return oldValue ~= newValue
    end
    function AutoConfig:StopMonitoring()
        self.IsMonitoring = false
    end
    
    function AutoConfig:ManualSave()
        return self:SaveConfig()
    end
    
    function AutoConfig:GetLastSaveTime()
        return self.LastSaveTime
    end
end

-- Window Creation
local Window = Fluent:CreateWindow({
    Title = "#DJSTEST - FISH IT V.0.7",
    SubTitle = "https://discord.gg/uwXYuxj6cF",
    TabWidth = 160,
    Size = UDim2.fromOffset(650, 500),
    Transparency = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.F
})
-- addTabs
local Tabs = {
    Info = Window:AddTab({ Title = "Info Script", Icon = "info" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user-cog" }),
    Fishing = Window:AddTab({ Title = "Fishing", Icon = "fish" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "map-pin" }),
    Buy = Window:AddTab({ Title = "Buy", Icon = "shopping-cart" }),
    Webhook = Window:AddTab({ Title = "Webhook", Icon = "bell-ring" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options
-- Variables for character setup
local defaultWalkSpeed = 16
local defaultJumpPower = 16
local isWalkSpeedActive = false
local currentWalkSpeed = 50

-- Character setup function
local function setupCharacter()
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if not Options.WalkSpeedSlider then
            defaultWalkSpeed = humanoid.WalkSpeed
        end
        if not Options.JumpHeightSlider then
            defaultJumpPower = humanoid.JumpPower
        end
        
        -- Apply walk speed based on toggle state
        if isWalkSpeedActive and Options.WalkSpeedSlider then
            humanoid.WalkSpeed = Options.WalkSpeedSlider.Value or currentWalkSpeed
        else
            humanoid.WalkSpeed = defaultWalkSpeed
        end
        
        if Options.JumpHeightSlider then
            humanoid.JumpPower = Options.JumpHeightSlider.Value or defaultJumpPower
        end
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacter)
if game.Players.LocalPlayer.Character then
    setupCharacter()
end

-- Info Tab
do
    Tabs.Info:AddButton({
        Title = "Discord Server",
        Description = "Discord invite link",
        Callback = function()
            setclipboard("https://discord.gg/uwXYuxj6cF")
        end
    })
    
    Tabs.Info:AddButton({
        Title = "Tiktok",
        Description = "Tiktok profile link",
        Callback = function()
            setclipboard("https://www.tiktok.com/@daanujs_")
        end
    })
end

-- Player Tab
do
   
    
    -- Walk Speed Slider
    local WalkSpeedSlider = Tabs.Player:AddSlider("WalkSpeedSlider", {
        Title = "Walk Speed",
        Description = "Control your walking speed",
        Default = 50,
        Min = 16,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            currentWalkSpeed = Value
            -- Only apply if toggle is active
            if isWalkSpeedActive then
                local player = game.Players.LocalPlayer
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.WalkSpeed = Value
                end
            end
        end
    })
    
    -- Jump Height
    local JumpHeightSlider = Tabs.Player:AddSlider("JumpHeightSlider", {
        Title = "Jump Height",
        Description = "Control your jumping power",
        Default = defaultJumpPower,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid.JumpPower = Value
            end
        end
    })
    
    -- Fly variables and functions
    local flyBodyVelocity = nil
    local flyBodyPosition = nil
    local isFlyActive = false
    local flySpeed = 50
    
    local FlySpeedSlider = Tabs.Player:AddSlider("FlySpeedSlider", {
        Title = "Fly Speed",
        Description = "Control your flying speed",
        Default = flySpeed,
        Min = 10,
        Max = 1000,
        Rounding = 5,
        Callback = function(Value)
            flySpeed = Value
        end
    })
    
    local function enableFly()
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return false
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        flyBodyVelocity.Parent = humanoidRootPart
        flyBodyPosition = Instance.new("BodyPosition")
        flyBodyPosition.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyPosition.Position = humanoidRootPart.Position
        flyBodyPosition.Parent = humanoidRootPart
        return true
    end
    
    local function disableFly()
        if flyBodyVelocity then
            flyBodyVelocity:Destroy()
            flyBodyVelocity = nil
        end
        if flyBodyPosition then
            flyBodyPosition:Destroy()
            flyBodyPosition = nil
        end
    end
    
    local function updateFlyMovement()
        local player = game.Players.LocalPlayer
        local camera = workspace.CurrentCamera
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not flyBodyVelocity or not flyBodyPosition or not humanoid then
            return
        end
        local moveVector = humanoid.MoveDirection
        local velocity = Vector3.new(0, 0, 0)
        if moveVector.Magnitude > 0 then
            local cameraDirection = camera.CFrame.LookVector
            local flatDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).Unit
            velocity = flatDirection * moveVector.Magnitude * flySpeed
        end
        local userInputService = game:GetService("UserInputService")
        if userInputService:IsKeyDown(Enum.KeyCode.Space) then
            velocity = velocity + Vector3.new(0, flySpeed, 0)
        end
        if userInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            velocity = velocity + Vector3.new(0, -flySpeed, 0)
        end
        flyBodyVelocity.Velocity = velocity
        if velocity.Magnitude == 0 then
            flyBodyPosition.Position = humanoidRootPart.Position
        else
            flyBodyPosition.Position = humanoidRootPart.Position + velocity * 0.1
        end
    end
     -- Walk Speed Toggle
    local WalkSpeedToggle = Tabs.Player:AddToggle("WalkSpeedToggle", {
        Title = "Walk Speed",
        Description = "Enable custom walk speed",
        Default = false,
        Callback = function(Value)
            isWalkSpeedActive = Value
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                if Value then
                    player.Character.Humanoid.WalkSpeed = currentWalkSpeed
                else
                    player.Character.Humanoid.WalkSpeed = defaultWalkSpeed
                end
            end
        end
    })
    local flyToggle = Tabs.Player:AddToggle("FlyToggle", {
        Title = "Fly",
        Description = "Enable flying mode",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isFlyActive then
                    if enableFly() then
                        isFlyActive = true
                        spawn(function()
                            while isFlyActive do
                                updateFlyMovement()
                                game:GetService("RunService").Heartbeat:Wait()
                            end
                        end)
                    end
                end
            else
                if isFlyActive then
                    isFlyActive = false
                    disableFly()
                end
            end
        end
    })
    
    -- Infinite Jump
    local infiniteJumpConnection = nil
    local isInfiniteJumpActive = false
    
    local function enableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
        end
        infiniteJumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    end
    
    local function disableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
            infiniteJumpConnection = nil
        end
    end
    
    local infiniteJump = Tabs.Player:AddToggle("InfiniteJump", {
        Title = "Infinite Jump",
        Description = "Jump infinitely without touching ground",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isInfiniteJumpActive then
                    enableInfiniteJump()
                    isInfiniteJumpActive = true
                end
            else
                if isInfiniteJumpActive then
                    disableInfiniteJump()
                    isInfiniteJumpActive = false
                end
            end
        end
    })
    
    -- No Clip
    local isNoclipActive = false
    local noclipConnection = nil
    local RunService = game:GetService("RunService")
    
    local function enableNoclip()
        local player = game.Players.LocalPlayer
        if not player.Character then
            return false
        end
        if noclipConnection then
            noclipConnection:Disconnect()
        end
        noclipConnection = RunService.Stepped:Connect(function()
            if not isNoclipActive then
                noclipConnection:Disconnect()
                return
            end
            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
        
        return true
    end
    
    local function disableNoclip()
        local player = game.Players.LocalPlayer
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    if part.Name == "Head" or part.Name:find("Torso") or part.Name:find("Arm") or part.Name:find("Leg") then
                        part.CanCollide = false
                    else
                        part.CanCollide = true
                    end
                end
            end
            if player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CanCollide = false
            end
        end
    end
    
    local function setupCharacterNoclip()
        local player = game.Players.LocalPlayer
        if player.Character and isNoclipActive then
            wait(0.5)
            enableNoclip()
        end
    end
    
    game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacterNoclip)
    
    local noclipToggle = Tabs.Player:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(Value)
            isNoclipActive = Value
            if Value then
                enableNoclip()
            else
                disableNoclip()
            end
        end
    })
    
    -- Anti AFK
    local antiAfkConnection = nil
    local isAntiAfkActive = false
    
    local antiAfkToggle = Tabs.Player:AddToggle("AntiAfk", {
        Title = "Anti AFK",
        Description = "Prevent getting kicked for being idle",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isAntiAfkActive then
                    local VirtualUser = game:GetService('VirtualUser')
                    antiAfkConnection = game:GetService('Players').LocalPlayer.Idled:Connect(function()
                        VirtualUser:CaptureController()
                        VirtualUser:ClickButton2(Vector2.new())
                    end)
                    isAntiAfkActive = true
                end
            else
                if antiAfkConnection and isAntiAfkActive then
                    antiAfkConnection:Disconnect()
                    antiAfkConnection = nil
                    isAntiAfkActive = false
                end
            end
        end
    })
    -- Auto Trade Section
    local isAutoTradeActive = false
    local isAutoGiveActive = false
    local autoTradeConnection = nil
    local hookApplied = false
    local originalCreateTradePrompt = nil

    local function setupAutoTrade()
        local success, error = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
            if Controllers then
                local ItemTradingController = Controllers:FindFirstChild("ItemTradingController")
                if ItemTradingController then
                    local controller = require(ItemTradingController)
                    if not originalCreateTradePrompt and controller.CreateTradePrompt then
                        originalCreateTradePrompt = controller.CreateTradePrompt
                    end
                    
                    controller.CreateTradePrompt = function(self, itemData, itemInfo, tradeInfo)
                        if isAutoTradeActive and tradeInfo and tradeInfo.sender then
                            local Promise = require(ReplicatedStorage.Packages.Promise)
                            return Promise.resolve(true)
                        end
                        
                        if isAutoGiveActive and tradeInfo and tradeInfo.target then
                            local Promise = require(ReplicatedStorage.Packages.Promise)
                            return Promise.resolve(true)
                        end
                        
                        if originalCreateTradePrompt then
                            return originalCreateTradePrompt(self, itemData, itemInfo, tradeInfo)
                        else
                            local Promise = require(ReplicatedStorage.Packages.Promise)
                            return Promise.reject("Original function not found")
                        end
                    end
                    hookApplied = true
                    if autoTradeConnection then
                        autoTradeConnection:Disconnect()
                    end
                    autoTradeConnection = game:GetService("RunService").Heartbeat:Connect(function()
                        if tick() % 5 < 0.1 then
                            local currentController = require(ItemTradingController)
                            if currentController.CreateTradePrompt ~= controller.CreateTradePrompt then
                                currentController.CreateTradePrompt = controller.CreateTradePrompt
                            end
                        end
                    end)
                    
                    return true
                end
            end
            
            warn("[AUTO ACCEPT] ItemTradingController not found!")
            return false
        end)
        
        if not success then
            warn("Auto accept setup error: " .. tostring(error))
            return false
        end
        return success
    end

    local function disableAutoTrade()
        local success, error = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
            
            if Controllers then
                local ItemTradingController = Controllers:FindFirstChild("ItemTradingController")
                if ItemTradingController then
                    local controller = require(ItemTradingController)
                    if originalCreateTradePrompt then
                        controller.CreateTradePrompt = originalCreateTradePrompt
                    end
                end
            end
            
            if autoTradeConnection then
                autoTradeConnection:Disconnect()
                autoTradeConnection = nil
            end
            
            hookApplied = false
            return true
        end)
        
        if not success then
            warn("Disable auto accept error: " .. tostring(error))
            return false
        end
        return success
    end
    local autoTradeToggle = Tabs.Player:AddToggle("AutoTrade", {
        Title = "Auto Trade",
        Description = "Automatically accept and give",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isAutoTradeActive and not isAutoGiveActive then
                    if setupAutoTrade() then
                        isAutoTradeActive = true
                        isAutoGiveActive = true
                    else
                        Options.AutoTrade:SetValue(false)
                    end
                end
            else
                if isAutoTradeActive or isAutoGiveActive then
                    isAutoTradeActive = false
                    isAutoGiveActive = false
                    disableAutoTrade()
                end
            end
        end
    })
end
do
local isAutoFishActive = false
local fishingDelay = 2.3 
local isAutoPerfectActive = false
local isAutoAmazingActive = false
local toolRefreshInterval = 300
local lastToolRefreshTime = 0
local function equipFishingTool()
   local success, error = pcall(function()
      local ReplicatedStorage = game:GetService("ReplicatedStorage")
      local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
      if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return false
      end
      local net = netFolder.net
      local equipTool = net:FindFirstChild("RE/EquipToolFromHotbar")
      if equipTool then
         equipTool:FireServer(1)
         return true
      end
      return false
   end)
   if not success then
      warn("Equip tool error: " .. tostring(error))
      return false
   end
   return success
end

local function unequipFishingTool()
   local success, error = pcall(function()
      local ReplicatedStorage = game:GetService("ReplicatedStorage")
      local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
      if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return false
      end
      local net = netFolder.net
      local unequipTool = net:FindFirstChild("RE/UnequipToolFromHotbar")
      if unequipTool then
         unequipTool:FireServer()
         return true
      end
      return false
   end)
   
   if not success then
      warn("Unequip tool error: " .. tostring(error))
      return false
   end
   return success
end

local function performFishingCycle()
 local success, error = pcall(function()
     local ReplicatedStorage = game:GetService("ReplicatedStorage")
     local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
     
     if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return
     end
     local net = netFolder.net
     local chargeFishingRod = net:FindFirstChild("RF/ChargeFishingRod")
     if chargeFishingRod then
         if isAutoPerfectActive then
             local value = 9999999999
             chargeFishingRod:InvokeServer(value)
         elseif isAutoAmazingActive then
             local value = 1755509015.922411
             chargeFishingRod:InvokeServer(value)
         else
             local value = math.random(8000, 10000)
             chargeFishingRod:InvokeServer(value)
         end
         task.wait(0.3)
     end
     local requestFishing = net:FindFirstChild("RF/RequestFishingMinigameStarted")
     if requestFishing then
         if isAutoPerfectActive then
             requestFishing:InvokeServer(0, 1)
         elseif isAutoAmazingActive then
             requestFishing:InvokeServer(-139.6379699707, 0.87694226394928)
         else
             local randomX = math.random(-200, 200) / 100
             local randomY = math.random(50, 100) / 100
             requestFishing:InvokeServer(randomX, randomY)
         end
     end
     task.wait(fishingDelay) -- Menggunakan fishingDelay yang bisa diatur slider
     local fishingCompleted = net:FindFirstChild("RE/FishingCompleted")
     if fishingCompleted then
         fishingCompleted:FireServer()
         task.wait(0.5)
         
         local currentTime = tick()
         if currentTime - lastToolRefreshTime >= toolRefreshInterval then
             lastToolRefreshTime = currentTime
             task.wait(1)
         end
     end
 end)
 if not success then
     warn("Fishing cycle error: " .. tostring(error))
 end
end
Tabs.Fishing:AddSection("Auto Fishing V1")
local FishingDelaySlider = Tabs.Fishing:AddSlider("FishingDelay", {
    Title = "Fishing Delay V1",
    Description = "Adjust delay between fishing cycles, Default 2.3",
    Default = 2.3,
    Min = 2,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        fishingDelay = Value
    end
})
local AutoFishingToggle = Tabs.Fishing:AddToggle("AutoFishing", {
   Title = "Auto Fishing V1",
   Description = "Automatically fish",
   Default = false,
   Callback = function(Value)
      if Value then
         if not isAutoFishActive then
            if equipFishingTool() then
               isAutoFishActive = true
               lastToolRefreshTime = tick()
               wait(1) 
               spawn(function()
                  while isAutoFishActive do
                     if not isAutoFishActive then break end 
                     performFishingCycle()
                     for i = 1, 10 do
                        if not isAutoFishActive then break end
                        wait(0.1)
                     end
                  end
               end)
            end
         end
      else
         if isAutoFishActive then
            isAutoFishActive = false 
            spawn(function()
               unequipFishingTool()
            end)
         end
      end
   end,
})

local AutoPerfectToggle = Tabs.Fishing:AddToggle("AutoPerfect", {
 Title = "Auto Perfect",
 Description = "Perfect catch every time",
 Default = false,
 Callback = function(Value)
     isAutoPerfectActive = Value
     if Value then
         isAutoAmazingActive = false
         Options.AutoAmazing:SetValue(false)
     end
 end,
})
local AutoPerfectToggle = Tabs.Fishing:AddToggle("AutoAmazing", {
 Title = "Auto Amazing",
 Description = "Amazing catch every time",
 Default = false,
 Callback = function(Value)
     isAutoAmazingActive = Value
     if Value then
         isAutoPerfectActive = false
         Options.AutoPerfect:SetValue(false)
     end
 end,
})

local SellFishButton = Tabs.Fishing:AddButton({
   Title = "Sell All Fish",
   Description = "Sell all fish in inventory",
   Callback = function()
      local success, error = pcall(function()
         local ReplicatedStorage = game:GetService("ReplicatedStorage")
         local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
         if netFolder and netFolder:FindFirstChild("net") then
            local net = netFolder.net
            local sellAllItems = net:FindFirstChild("RF/SellAllItems")
            if sellAllItems then
               sellAllItems:InvokeServer()
            end
         end
      end)
   end,
})
Tabs.Fishing:AddSection("Auto Fishing V2")
local isAutoFishV2Active = false
local fishingV2DelayTime = 3
local fishingControllerModule = nil
local function getFishingController()
    if fishingControllerModule then
        return fishingControllerModule
    end
    
    local success, result = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
        if Controllers then
            local FishingController = Controllers:FindFirstChild("FishingController")
            if FishingController then
                return require(FishingController)
            end
        end
        return nil
    end)
    
    if success and result then
        fishingControllerModule = result
        return fishingControllerModule
    end
    
    return nil
end
local function canStartFishing()
    local controller = getFishingController()
    if not controller then
        return false, "Controller not found"
    end
    
    local success, result = pcall(function()
        return not controller:OnCooldown()
    end)
    
    if success then
        return result, result and "Ready" or "On cooldown"
    end
    
    return false, "Error checking cooldown"
end
local function performNaturalFishingCycle()
    local success, error = pcall(function()
        local controller = getFishingController()
        if not controller then
            warn("[AUTO FISHING V2] Controller not found")
            return false
        end
        
        local Players = game:GetService("Players")
        local camera = workspace.CurrentCamera
        local screenCenter = Vector2.new(
            camera.ViewportSize.X / 2,
            camera.ViewportSize.Y / 2
        )
        local canFish, reason = canStartFishing()
        if not canFish then
            warn("[AUTO FISHING V2] Cannot fish: " .. reason)
            return false
        end
        controller:RequestChargeFishingRod(screenCenter, true, true)
        local waitTime = 0
        local maxWait = 15
        
        while waitTime < maxWait and isAutoFishV2Active do
            local currentGUID = controller:GetCurrentGUID()
            if currentGUID then
                controller:RequestFishingMinigameClick()
            else
                task.wait(0.5)
                local stillInFishing = controller:GetCurrentGUID()
                if not stillInFishing and waitTime > 2 then
                    break
                end
            end
            
            task.wait(0.1)
            waitTime = waitTime + 0.1
        end
        
        return true
    end)
    if not success then
        warn("[AUTO FISHING V2] Error in fishing cycle: " .. tostring(error))
        return false
    end
    return success
end
local autoFishV2Toggle = Tabs.Fishing:AddToggle("AutoFishingV2", {
    Title = "Auto Fishing V2",
    Description = "testt",
    Default = false,
    Callback = function(Value)
        isAutoFishV2Active = Value
        if Value then
            local controller = getFishingController()
            if not controller then
                Options.AutoFishingV2:SetValue(false)
                return
            end
            spawn(function()
                while isAutoFishV2Active do
                    if not isAutoFishV2Active then break end
                    local cycleSuccess = performNaturalFishingCycle()
                    for i = 1, fishingV2DelayTime * 10 do
                        if not isAutoFishV2Active then break end
                        task.wait(0.1)
                    end
                end
            end)
        end
    end
})
local fishingV2DelaySlider = Tabs.Fishing:AddSlider("FishingV2Delay", {
    Title = "Fishing Delay V2",
    Description = "Delay between fishing cycles (seconds)",
    Default = 3,
    Min = 2,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        fishingV2DelayTime = Value
    end
})
local isAutoClickV2Active = false
local autoClickV2Toggle = Tabs.Fishing:AddToggle("AutoClickV2", {
    Title = "Auto Click",
    Description = "For auto fishing v2",
    Default = false,
    Callback = function(Value)
        isAutoClickV2Active = Value
        if Value then
            spawn(function()
                while isAutoClickV2Active do
                    local success, error = pcall(function()
                        local controller = getFishingController()
                        if controller then
                            local currentGUID = controller:GetCurrentGUID()
                            if currentGUID then
                                for i = 1, 3 do
                                    controller:RequestFishingMinigameClick()
                                    task.wait(0.05)
                                end
                            end
                        end
                    end)
                    if not success then
                        warn("[AUTO CLICK V2] Error: " .. tostring(error))
                    end
                    task.wait(0.1)
                end
            end)
        end
    end
})
Tabs.Fishing:AddSection("Auto Farm V1")
local selectedFarmLocation = nil
local isAutoFarmActive = false
local selectedFarmMethodV1 = "V1"
local farmLocations = {
   ["Kohana"] = CFrame.new(-686.516663, 3.035492, 799.652039, -0.999842, 0.000000, 0.017792, 0.000000, 1.000000, -0.000000, -0.017792, -0.000000, -0.999842),
   ["Kohana Volcano"] = CFrame.new(-634.442505, 56.306618, 203.509964, 0.649667, -0.000000, 0.760219, -0.000000, 1.000000, 0.000000, -0.760219, -0.000000, 0.649667),
   ["Tropical Grove"] = CFrame.new(-2134.633301, 6.646839, 3641.041016, -0.787255, 0.000000, -0.616627, 0.000000, 1.000000, -0.000000, 0.616627, -0.000000, -0.787255),
   ["Tropical Grove 2"] = CFrame.new(-2202.405762, 25.430653, 3607.925781, 0.457824, 0.000000, 0.889043, 0.000000, 1.000000, -0.000000, -0.889043, 0.000000, 0.457824),
   ["Sisyphus Statue"] = CFrame.new(-3730.283203, -99.316132, -947.356995, 0.871698, 0.000000, 0.490044, -0.000000, 1.000000, 0.000000, -0.490044, -0.000000, 0.871698),
   ["Weather Machine"] = CFrame.new(-1541.473877, 2.875000, 1918.276733, -0.984437, 0.000000, 0.175738, 0.000000, 1.000000, -0.000000, -0.175738, -0.000000, -0.984437),
   ["Treasure Room"] = CFrame.new(-3650.865479, -279.073822, -1615.960327, 0.518514, -0.000000, -0.855069, 0.000000, 1.000000, 0.000000, 0.855069, -0.000000, 0.518514),
   ["Esoteric Island"] = CFrame.new(1988.061768, 7.207217, 1363.772339, 0.031890, -0.000000, 0.999491, -0.000000, 1.000000, 0.000000, -0.999491, -0.000000, 0.031890),
   ["Crater Island"] = CFrame.new(991.782410, 7.904960, 5082.351562, -0.711836, -0.000000, 0.702345, 0.000000, 1.000000, 0.000000, -0.702345, 0.000000, -0.711836),
   ["Coral Reefs"] = CFrame.new(-3212.688477, 10.198070, 2004.139648, 0.778372, -0.000000, -0.627804, 0.000000, 1.000000, -0.000000, 0.627804, -0.000000, 0.778372),
   ["Stingray Shores"] = CFrame.new(-182.069839, 3.134159, 2789.177246, 0.013366, -0.000000, 0.999911, -0.000000, 1.000000, 0.000000, -0.999911, -0.000000, 0.013366),
   ["Ocean"] = CFrame.new(1756.653687, 2.299988, 3358.764893, 0.200904, -0.000000, -0.979611, 0.000000, 1.000000, -0.000000, 0.979611, -0.000000, 0.200904),
   ["Esoteric Depths"] = CFrame.new(3231.490234, -1302.105103, 1453.461060, 0.988762, 0.000000, -0.149498, -0.000000, 1.000000, -0.000000, 0.149498, 0.000000, 0.988762)
}
local FarmLocationDropdown = Tabs.Fishing:AddDropdown("FarmLocation", {
   Title = "Auto Farm V1 - Select Map",
   Description = "Choose location for auto farming",
   Values = {
      "Kohana", "Kohana Volcano", "Tropical Grove", "Tropical Grove 2",
      "Sisyphus Statue", "Weather Machine", "Treasure Room", "Esoteric Island",
      "Crater Island", "Coral Reefs", "Stingray Shores", "Ocean", "Esoteric Depths"
   },
   Multi = false,
   Default = 1,
})
FarmLocationDropdown:OnChanged(function(Value)
   selectedFarmLocation = Value
end)
local function startAutoFarm()
   if not selectedFarmLocation then return false end
   local player = game.Players.LocalPlayer
   if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end

   local targetCFrame = farmLocations[selectedFarmLocation]
   if targetCFrame then
      player.Character.HumanoidRootPart.CFrame = targetCFrame
      wait(2)

      -- aktifkan method sesuai dropdown
      if selectedFarmMethodV1 == "V1" then
         Options.AutoFishing:SetValue(true)
      else
         Options.AutoFishingV2:SetValue(true)
      end

      spawn(function()
         while isAutoFarmActive do
            wait(5)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
               local currentPos = player.Character.HumanoidRootPart.Position
               local targetPos = targetCFrame.Position
               local distance = (currentPos - targetPos).Magnitude
               if distance > 50 then
                  player.Character.HumanoidRootPart.CFrame = targetCFrame
                  -- refresh toggle
                  if selectedFarmMethodV1 == "V1" then
                     Options.AutoFishing:SetValue(false)
                     wait(1)
                     Options.AutoFishing:SetValue(true)
                  else
                     Options.AutoFishingV2:SetValue(false)
                     wait(1)
                     Options.AutoFishingV2:SetValue(true)
                  end
               end
            end
         end
      end)
      return true
   end
   return false
end
local function stopAutoFarm()
   isAutoFarmActive = false
   Options.AutoFishing:SetValue(false) 
end
local FarmMethodV1Dropdown = Tabs.Fishing:AddDropdown("FarmMethodV1", {
    Title = "Auto Farm V1 - Select Method",
    Description = "Choose fishing method for Auto Farm V1",
    Values = {"V1", "V2"},
    Multi = false,
    Default = 1,
})
FarmMethodV1Dropdown:OnChanged(function(Value)
    selectedFarmMethodV1 = Value
end)
local AutoFarmV1Toggle = Tabs.Fishing:AddToggle("AutoFarmV1", {
   Title = "Start Auto Farm V1",
   Description = "Start farming at selected location",
   Default = false,
   Callback = function(Value)
      if Value then
         if not isAutoFarmActive then
            isAutoFarmActive = true
            if not startAutoFarm() then
               isAutoFarmActive = false
               Options.AutoFarmV1:SetValue(false)
            end
         end
      else
         if isAutoFarmActive then
            stopAutoFarm()
         end
      end
   end,
})
Tabs.Fishing:AddSection("Auto Farm V2")
local selectedFarmMethodV2 = "V1"
local CheckpointInput = Tabs.Fishing:AddInput("CheckpointInput", {
    Title = "Dont' touch this!",
    Description = "Checkpoint Status",
    Default = "",
    Placeholder = "......",
    Numeric = false,
    Finished = false,
    Callback = function(Value)
        -- Parse coordinate string back to CFrame if valid
        if Value and Value ~= "" then
            local coords = {}
            for num in Value:gmatch("([%-%d%.]+)") do
                table.insert(coords, tonumber(num))
            end
            if #coords >= 12 then
                checkpointPosition = CFrame.new(unpack(coords))
                hasCheckpoint = true
            end
        else
            checkpointPosition = nil
            hasCheckpoint = false
        end
    end
})
local function cframeToString(cframe)
    if not cframe then return "" end
    local components = {cframe:GetComponents()}
    return string.format("%.2f, %.2f, %.2f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f", unpack(components))
end
local SetCheckpointButton = Tabs.Fishing:AddButton({
    Title = "Set Location",
    Description = "Save current position as farming location",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            checkpointPosition = player.Character.HumanoidRootPart.CFrame
            hasCheckpoint = true
            local coordString = cframeToString(checkpointPosition)
            Options.CheckpointInput:SetValue(coordString)
        end
    end,
})
local ClearCheckpointButton = Tabs.Fishing:AddButton({
    Title = "Clear Location",
    Description = "Remove saved position",
    Callback = function()
        checkpointPosition = nil
        hasCheckpoint = false
        if isAutoFarmV2Active then
            Options.AutoFarmV2:SetValue(false)
        end
        Options.CheckpointInput:SetValue("")
    end,
})
local function startAutoFarmV2()
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end

    player.Character.HumanoidRootPart.CFrame = checkpointPosition
    wait(2)

    -- aktifkan method sesuai dropdown
    if selectedFarmMethodV2 == "V1" then
        Options.AutoFishing:SetValue(true)
    else
        Options.AutoFishingV2:SetValue(true)
    end

    spawn(function()
        while isAutoFarmV2Active do
            wait(5)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local currentPos = player.Character.HumanoidRootPart.Position
                local checkpointPos = checkpointPosition.Position
                local distance = (currentPos - checkpointPos).Magnitude
                if distance > 50 then
                    player.Character.HumanoidRootPart.CFrame = checkpointPosition
                    -- refresh toggle
                    if selectedFarmMethodV2 == "V1" then
                        Options.AutoFishing:SetValue(false)
                        wait(1)
                        Options.AutoFishing:SetValue(true)
                    else
                        Options.AutoFishingV2:SetValue(false)
                        wait(1)
                        Options.AutoFishingV2:SetValue(true)
                    end
                end
            end
        end
    end)
    return true
end

local FarmMethodV2Dropdown = Tabs.Fishing:AddDropdown("FarmMethodV2", {
    Title = "Auto Farm V2 - Select Method",
    Description = "Choose fishing method for Auto Farm V2",
    Values = {"V1", "V2"},
    Multi = false,
    Default = 1,
})
FarmMethodV2Dropdown:OnChanged(function(Value)
    selectedFarmMethodV2 = Value
end)
local function stopAutoFarmV2()
    isAutoFarmV2Active = false
    Options.AutoFishing:SetValue(false)
end

local AutoFarmV2Toggle = Tabs.Fishing:AddToggle("AutoFarmV2", {
    Title = "Start Auto Farm V2",
    Description = "Farm at your saved location",
    Default = false,
    Callback = function(Value)
        if Value then
            if not isAutoFarmV2Active then
                isAutoFarmV2Active = true
                if not startAutoFarmV2() then
                    isAutoFarmV2Active = false
                    Options.AutoFarmV2:SetValue(false)
                end
            end
        else
            if isAutoFarmV2Active then
                stopAutoFarmV2()
            end
        end
    end,
})

spawn(function()
    wait(5) -- tunggu config dan checkpoint input benar2 loaded
    if Options.AutoFarmV2 and Options.AutoFarmV2.Value == true then
        if hasCheckpoint and checkpointPosition then
            Options.AutoFarmV2:SetValue(false)
            wait(3)
            Options.AutoFarmV2:SetValue(true)
        else
            Options.AutoFarmV2:SetValue(false)
        end
    end
end)


spawn(function()
    wait(3) -- Wait untuk config loading selesai
    local inputValue = Options.CheckpointInput and Options.CheckpointInput.Value or ""
    if inputValue ~= "" then
        local coords = {}
        for num in inputValue:gmatch("([%-%d%.]+)") do
            table.insert(coords, tonumber(num))
        end
        if #coords >= 12 then
            checkpointPosition = CFrame.new(unpack(coords))
            hasCheckpoint = true
            local pos = checkpointPosition.Position
            local infoText = string.format("X: %.1f, Y: %.1f, Z: %.1f", pos.X, pos.Y, pos.Z)
        end
    end
end)
end
do
    local teleportTab = Tabs.Teleport
    
    -- Player Teleport Section
    local currentPlayerList = {}
    local isDropdownInitialized = false
    local lastSelectedOption = "Select a player..."

    local function getPlayerList()
        local players = {}
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                table.insert(players, player.Name)
            end
        end
        return players
    end

    local function updatePlayerDropdown()
        currentPlayerList = getPlayerList()
        if Options.TeleportToPlayer then
            if #currentPlayerList > 0 then
                local options = {"Select a player..."}
                for _, playerName in ipairs(currentPlayerList) do
                    table.insert(options, playerName)
                end
                Options.TeleportToPlayer:SetValues(options)
            end
        end
    end

    local function teleportToPlayer(playerName)
        if not isDropdownInitialized then return end
        if playerName == lastSelectedOption then return end
        lastSelectedOption = playerName
        if playerName == "No players available" or playerName == "Select a player..." then
            return
        end

        local success, error = pcall(function()
            local targetPlayer = game.Players:FindFirstChild(playerName)
            local localPlayer = game.Players.LocalPlayer

            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                return
            end

            if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                return
            end

            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local offsetPosition = targetPosition + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(offsetPosition)
        end)
    end

    currentPlayerList = getPlayerList()
    local playerTeleportDropdown = teleportTab:AddDropdown("TeleportToPlayer", {
        Title = "Teleport To Player",
        Description = "Select a player to teleport to",
        Values = #currentPlayerList > 0 and (function() 
            local options = {"Select a player..."}
            for _, playerName in ipairs(currentPlayerList) do
                table.insert(options, playerName)
            end
            return options
        end)() or {"Select a player...", "No players available"},
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select a player..." or Value == "No players available" then
                return
            end
            
            if Value and isDropdownInitialized then
                spawn(function()
                    wait(0.1)
                    teleportToPlayer(Value)
                    -- Reset to default after teleport
                    Options.TeleportToPlayer:SetValue("Select a player...")
                end)
            end
        end
    })

    spawn(function()
        wait(2)
        isDropdownInitialized = true
    end)

    local refreshPlayerButton = teleportTab:AddButton({
        Title = "Refresh Player List",
        Description = "Update the list of available players",
        Callback = function()
            updatePlayerDropdown()
        end
    })

    -- Island Teleport Section
    teleportTab:AddSection("Islands")
    
    local islandTeleportDropdown = teleportTab:AddDropdown("TeleportIsland", {
        Title = "Teleport To Island",
        Description = "Select an island to teleport to",
        Values = {
            "Select Island...",
            "Kohana",
            "Kohana Volcano",
            "Tropical Grove",
            "Sisyphus Statue",
            "Weather Machine",
            "Treasure Room",
            "Esoteric Island",
            "Crater Island",
            "Coral Reefs",
            "Stingray Shores",
            "Ocean",
            "Esoteric Depths"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Island..." then
                return
            end
            
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            local locations = {
                ["Kohana"] = CFrame.new(-666.27771, 0.946365654, 719.934326, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                ["Kohana Volcano"] = CFrame.new(-484.600891, 20.750059, 227.483047, -0.750139, -0.000000, -0.661280, -0.000000, 1.000000, -0.000000, 0.661280, 0.000000, -0.750139),
                ["Tropical Grove"] = CFrame.new(-2063.47021, 3.99908447, 3643.12622, -0.0675487518, 0, 0.99771595, 0, 1, 0, -0.99771595, 0, -0.0675487518),
                ["Sisyphus Statue"] = CFrame.new(-3729.36743, -100.94648, -948.056519, 0.881157279, -0.202546716, 0.427243084, 9.03755426e-06, 0.90360719, 0.428362042, -0.472823232, -0.377450496, 0.796221912),
                ["Weather Machine"] = CFrame.new(-1492.293091, 3.500000, 1903.266235, 0.037160, -0.000000, -0.999309, -0.000000, 1.000000, -0.000000, 0.999309, 0.000000, 0.037160),
                ["Treasure Room"] = CFrame.new(-3599.518799, -315.629181, -1418.691650, 0.999777, -0.000000, -0.021134, 0.000000, 1.000000, -0.000000, 0.021134, 0.000000, 0.999777),
                ["Esoteric Island"] = CFrame.new(2061.76196, 35.6500702, 1380.32703, 1, 0, 0, 0, 1, 0, 0, 0, 1),
                ["Crater Island"] = CFrame.new(976.711548, -5.2534189, 4886.73242, 0.173624337, -0, -0.984811902, 0, 1, -0, 0.984811902, 0, 0.173624337),
                ["Coral Reefs"] = CFrame.new(-3120.34644, 16.9453125, 2181.97144, 0.707134247, -0, -0.707079291, 0, 1, -0, 0.707079291, 0, 0.707134247),
                ["Stingray Shores"] = CFrame.new(32.029018, 9.784778, 2813.289551, 0.980407, -0.000000, 0.196984, 0.000000, 1.000000, -0.000000, -0.196984, 0.000000, 0.980407),
                ["Ocean"] = CFrame.new(1609.45593, 7.993308318, 3279.21533, 0.499959469, 0, 0.866048813, 0, 1, 0, -0.866048813, 0, 0.499959469),
                ["Esoteric Depths"] = CFrame.new(3054.9707, -1288.35474, 1483.97412, 0.90629667, 0, 0.422642082, 0, 1, 0, -0.422642082, 0, 0.90629667)
            }
            if locations[Value] then
                player.Character.HumanoidRootPart.CFrame = locations[Value]
                spawn(function()
                    wait(0.1)
                    Options.TeleportIsland:SetValue("Select Island...")
                end)
            end
        end
    })

    -- NPC Teleport Section  
    teleportTab:AddSection("NPCs")
    
    local npcTeleportDropdown = teleportTab:AddDropdown("TeleportNPC", {
        Title = "Teleport To NPC",
        Description = "Select an NPC to teleport to",
        Values = {
            "Select NPC...",
            "Alex - Sell Fish",
            "Billy Bob - Rod Skin",
            "Boat Expert - Boat Shop",
            "Joe - Rod Shop",
            "Scientist - Lucky Potion",
            "Scoot - Boat Shop",
            "Seth - Bait Shop",
            "Silly Fisherman"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select NPC..." then
                return
            end
            
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            local npcLocations = {
                ["Alex - Sell Fish"] = CFrame.new(48.656158, 17.071970, 2868.007812, -0.997883, 0.000000, 0.065036, 0.000000, 1.000000, -0.000000, -0.065036, -0.000000, -0.997883),
                ["Billy Bob - Rod Skin"] = CFrame.new(80.990456, 17.071970, 2869.381348, -0.958304, 0.000000, 0.285750, 0.000000, 1.000000, -0.000000, -0.285750, -0.000000, -0.958304),
                ["Boat Expert - Boat Shop"] = CFrame.new(22.869276, 4.045772, 2810.912354, 0.999303, -0.000000, 0.037339, 0.000000, 1.000000, 0.000000, -0.037339, -0.000000, 0.999303),
                ["Joe - Rod Shop"] = CFrame.new(142.136551, 20.459019, 2855.692871, -0.993222, 0.000000, -0.116233, 0.000000, 1.000000, -0.000000, 0.116233, -0.000000, -0.993222),
                ["Scientist - Lucky Potion"] = CFrame.new(-7.974049, 4.500001, 2844.862305, -0.999788, -0.000000, -0.020568, -0.000000, 1.000000, 0.000000, 0.020568, 0.000000, -0.999788),
                ["Scoot - Boat Shop"] = CFrame.new(-75.6783218, 4.74903107, 2867.15674, 0.305231869, -2.02933879e-05, 0.952278197, 0.000808718964, 0.999999642, -0.000237909742, -0.952277839, 0.000842742971, 0.30523181),
                ["Seth - Bait Shop"] = CFrame.new(112.343651, 17.071970, 2869.337402, -0.953610, 0.000000, 0.301044, -0.000000, 1.000000, -0.000000, -0.301044, -0.000000, -0.953610),
                ["Silly Fisherman"] = CFrame.new(90.683128, 27.244699, 3005.096436, -0.739958, 0.000000, -0.672653, 0.000000, 1.000000, 0.000000, 0.672653, 0.000000, -0.739958)
            }
            
            if npcLocations[Value] then
                player.Character.HumanoidRootPart.CFrame = npcLocations[Value]
                spawn(function()
                    wait(0.1)
                    Options.TeleportNPC:SetValue("Select NPC...")
                end)
            end
        end
    })
 teleportTab:AddSection("Events")
    
    local detectedEvents = {}
    local selectedEvent = nil
    local eventCoordinates = {
        ["Shark Hunt"] = {
            Vector3.new(1.64999, 5, 2095.72),
            Vector3.new(1369.94, 5, 930.125),
            Vector3.new(-1585.5, 5, 1242.87),
            Vector3.new(-1896.8, 5, 2634.37)
        },
        ["Ghost Shark Hunt"] = {
            Vector3.new(489.558, 5, 25.4060),
            Vector3.new(1976.51, 5, 2915.93),
            Vector3.new(-1358.2, 5, 4100.55),
            Vector3.new(627.859, 5, 3798.08)
        },
        ["Sparkling Cove"] = {
            Vector3.new(195.378, 5, 2976.27)
        },
        ["Worm Hunt"] = {
            Vector3.new(1591.55, 5, -105.92),
            Vector3.new(-2450.6, 5, 139.731),
            Vector3.new(-267.47, 5, 5188.53)
        },
        ["Admin - Shocked"] = {
            Vector3.new(383, 5, 2452)
        },
        ["Admin - Black Hole"] = {
            Vector3.new(883, 5, 2542)
        },
        ["Admin - Ghost Worm"] = {
            Vector3.new(-327, 5, 2422)
        },
        ["Admin - Meteor Rain"] = {
            Vector3.new(383, 5, 2452)
        },
        ["Storm"] = {Vector3.new(-1492.293091, 3.500000, 1903.266235)},
        ["Snow"] = {Vector3.new(-1492.293091, 3.500000, 1903.266235)},
        ["Wind"] = {Vector3.new(-1492.293091, 3.500000, 1903.266235)},
        ["Cloudy"] = {Vector3.new(-1492.293091, 3.500000, 1903.266235)}
    }

    local function detectActiveEvents()
        local activeEvents = {}
        
        local success, error = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local workspaceProps = workspace:FindFirstChild("Props")
            
            if workspaceProps and workspaceProps:FindFirstChild("Shark Hunt") then
                table.insert(activeEvents, "Shark Hunt 🟢")
            end
            if workspaceProps and workspaceProps:FindFirstChild("Ghost Shark Hunt") then
                table.insert(activeEvents, "Ghost Shark Hunt 🟢")
            end
            
            local lighting = game:GetService("Lighting")
            if lighting:FindFirstChild("SparklingCoveEffect") or 
               (lighting.Brightness > 1.5 and lighting.ColorShift_Top.R > 0.8 and lighting.ColorShift_Top.G > 0.8) then
                table.insert(activeEvents, "Sparkling Cove 🟢")
            end
            
            local PlayerGui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
            local wormHuntActive = false
            if PlayerGui then
                for _, gui in pairs(PlayerGui:GetDescendants()) do
                    if gui:IsA("TextLabel") and gui.Text then
                        if string.match(gui.Text, "Worm Hunt") and 
                           (string.match(gui.Text, "%d+:%d+") or string.match(gui.Text, "ACTIVE")) then
                            wormHuntActive = true
                            break
                        end
                    end
                end
            end
            
            if wormHuntActive or (workspaceProps and workspaceProps:FindFirstChild("Worm Hunt")) then
                table.insert(activeEvents, "Worm Hunt 🟢")
            end
            
            local adminAreas = workspace:FindFirstChild("AdminAreas") or workspace:FindFirstChild("AdminEvents")
            if adminAreas then
                if adminAreas:FindFirstChild("Shocked") or adminAreas:FindFirstChild("ShockedArea") then
                    table.insert(activeEvents, "Admin - Shocked 🟢")
                end
                if adminAreas:FindFirstChild("BlackHole") or adminAreas:FindFirstChild("Black Hole") then
                    table.insert(activeEvents, "Admin - Black Hole 🟢")
                end
                if adminAreas:FindFirstChild("GhostWorm") or adminAreas:FindFirstChild("Ghost Worm") then
                    table.insert(activeEvents, "Admin - Ghost Worm 🟢")
                end
                if adminAreas:FindFirstChild("MeteorRain") or adminAreas:FindFirstChild("Meteor Rain") then
                    table.insert(activeEvents, "Admin - Meteor Rain 🟢")
                end
            end
            
            if lighting.Brightness >= 3.5 and lighting.Ambient.B >= 0.6 and lighting.Ambient.R < 0.4 then
                table.insert(activeEvents, "Storm 🟢")
            end
            if lighting.ColorShift_Top.R <= 0.03 and lighting.ColorShift_Top.G <= 0.03 and lighting.ColorShift_Top.B <= 0.03 and
               lighting.Brightness < 1 then
                table.insert(activeEvents, "Snow 🟢")
            end
            local atmosphere = lighting:FindFirstChild("Atmosphere")
            if atmosphere and atmosphere.Density >= 1.0 and lighting.Brightness > 1.2 then
                table.insert(activeEvents, "Wind 🟢")
            end
            if lighting.Brightness <= 0.4 and 
               lighting.ColorShift_Top.R >= 0.8 and lighting.ColorShift_Top.G >= 0.8 and lighting.ColorShift_Top.B >= 0.8 then
                table.insert(activeEvents, "Cloudy 🟢")
            end
        end)
        
        if success then
            detectedEvents = activeEvents
            if #detectedEvents == 0 then
                detectedEvents = {"No active events"}
            end
        else
            warn("Error detecting events: " .. tostring(error))
            detectedEvents = {"Error detecting events"}
        end
        
        return detectedEvents
    end

    local function getEventCoordinates(selection)
        local cleanName = string.gsub(selection, " 🟢", "")
        cleanName = string.gsub(cleanName, "^%s*(.-)%s*$", "%1") 
        if eventCoordinates[cleanName] then
            local coords = eventCoordinates[cleanName]
            
            if #coords > 1 then
                local selectedCoord = coords[math.random(1, #coords)]
                return selectedCoord
            else
                return coords[1]
            end
        end
        return nil
    end

    detectActiveEvents()
    local eventDropdown = teleportTab:AddDropdown("EventTeleport", {
        Title = "Active Events",
        Description = "Select an active event to teleport to",
        Values = #detectedEvents > 0 and (function()
            local options = {"Select Event..."}
            for _, event in ipairs(detectedEvents) do
                table.insert(options, event)
            end
            return options
        end)() or {"Select Event...", "No events detected"},
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Event..." or Value == "No events detected" then
                return
            end
            
            selectedEvent = Value
            
            -- Auto teleport when selected
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            local targetPos = getEventCoordinates(selectedEvent)
            if targetPos then
                local offsetPos = targetPos + Vector3.new(
                    math.random(-5, 5),
                    0,
                    math.random(-5, 5)
                )
                player.Character.HumanoidRootPart.CFrame = CFrame.new(offsetPos)
                
                if Options.FlyToggle then
                    Options.FlyToggle:SetValue(true)
                end
                spawn(function()
                    wait(0.1)
                    Options.EventTeleport:SetValue("Select Event...")
                end)
            end
        end
    })
    local refreshEventsButton = teleportTab:AddButton({
        Title = "Refresh Events",
        Description = "Scan for currently active events",
        Callback = function()
            detectActiveEvents()
            if Options.EventTeleport then
                local options = {}
                for _, event in ipairs(detectedEvents) do
                    table.insert(options, event)
                end
                Options.EventTeleport:SetValues(options)
                selectedEvent = nil
                
                local activeCount = 0
                for _, event in ipairs(detectedEvents) do
                    if string.find(event, "🟢") then
                        activeCount = activeCount + 1
                    end
                end
            end
        end
    })

    local teleportEventButton = teleportTab:AddButton({
        Title = "Teleport To Event",
        Description = "Teleport to the selected event location",
        Callback = function()
            if not selectedEvent or selectedEvent == "No active events" or selectedEvent == "Error detecting events" then
                return
            end
            
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            local targetPos = getEventCoordinates(selectedEvent)
            if targetPos then
                local offsetPos = targetPos + Vector3.new(
                    math.random(-5, 5),
                    0,
                    math.random(-5, 5)
                )
                player.Character.HumanoidRootPart.CFrame = CFrame.new(offsetPos)
                
                if Options.FlyToggle then
                    Options.FlyToggle:SetValue(true)
                end
            end
        end
    })
    -- local copycords = teleportTab:AddButton({
    --     Title = "Copy Coords",
    --     Description = "copy coords",
    --     Callback = function()
    --                 local player = game.Players.LocalPlayer
    --     if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
    --         local pos = player.Character.HumanoidRootPart.CFrame
    --         -- Format ke string
    --         local coordsString = string.format(
    --             "CFrame.new(%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f)",
    --             pos:GetComponents()
    --         )
    --         setclipboard(coordsString)
    --     end
    --     end
    -- })
end

do
    local buyTab = Tabs.Buy
    
    -- Buy Weather Section
    local weatherDropdown = buyTab:AddDropdown("BuyWeather", {
        Title = "Buy Weather",
        Description = "Purchase weather events with coins",
        Values = {
            "Select Weather...",
            "Cloudy (20,000)",
            "Wind (10,000)",
            "Snow (15,000)",
            "Storm (35,000)",
            "Shark Hunt (300,000)"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Weather..." then
                return
            end
            
            local weatherName
            if Value:find("Cloudy") then
                weatherName = "Cloudy"
            elseif Value:find("Wind") then
                weatherName = "Wind"
            elseif Value:find("Snow") then
                weatherName = "Snow"
            elseif Value:find("Storm") then
                weatherName = "Storm"
            elseif Value:find("Shark Hunt") then
                weatherName = "Shark Hunt"
            end
            
            if weatherName then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyWeather = net:FindFirstChild("RF/PurchaseWeatherEvent")
                        if buyWeather then
                            buyWeather:InvokeServer(weatherName)
                        else
                            warn("PurchaseWeatherEvent not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Weather purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyWeather:SetValue("Select Weather...")
                end)
            end
        end
    })
    
    -- Buy Rod Section
    buyTab:AddSection("Fishing Equipment")
    
    local rodDropdown = buyTab:AddDropdown("BuyRod", {
        Title = "Buy Fishing Rod",
        Description = "Purchase fishing rods to improve your fishing",
        Values = {
            "Select Rod...",
            "Lucky Rod - 350",
            "Carbon Rod - 900",
            "Grass Rod - 1,500",
            "Damascus Rod - 3,000",
            "Ice Rod - 5,000",
            "Lucky Rod Pro - 15,000",
            "Midnight Rod - 50,000",
            "Steampunk Rod - 215,000",
            "Chrome Rod - 437,000",
            "Astral Rod - 1,000,000"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Rod..." then
                return
            end
            
            local rodId
            local rodName = Value
            
            if Value:find("Lucky Rod - 350") then
                rodId = 79
            elseif Value:find("Carbon Rod") then
                rodId = 76
            elseif Value:find("Grass Rod") then
                rodId = 85
            elseif Value:find("Damascus Rod") then
                rodId = 77
            elseif Value:find("Ice Rod") then
                rodId = 78
            elseif Value:find("Lucky Rod Pro") then
                rodId = 4
            elseif Value:find("Midnight Rod") then
                rodId = 80
            elseif Value:find("Steampunk Rod") then
                rodId = 6
            elseif Value:find("Chrome Rod") then
                rodId = 7
            elseif Value:find("Astral Rod") then
                rodId = 5
            end
            
            if rodId then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyRod = net:FindFirstChild("RF/PurchaseFishingRod")
                        if buyRod then
                            buyRod:InvokeServer(rodId)
                        else
                            warn("PurchaseFishingRod not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Rod purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyRod:SetValue("Select Rod...")
                end)
            end
        end
    })
    
    -- Buy Bait Section
    local baitDropdown = buyTab:AddDropdown("BuyBait", {
        Title = "Buy Bait",
        Description = "Purchase different types of bait for better catches",
        Values = {
            "Select Bait...",
            "Topwater Bait - 100",
            "Lucky Bait - 1,000",
            "Midnight Bait - 3,000",
            "Chroma Bait - 290,000",
            "Dark Matter Bait - 630,000",
            "Corrupt Bait - 1,150,000"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Bait..." then
                return
            end
            
            local baitId
            local baitName = Value
            
            if Value:find("Topwater Bait") then
                baitId = 10
            elseif Value:find("Lucky Bait") then
                baitId = 2
            elseif Value:find("Midnight Bait") then
                baitId = 3
            elseif Value:find("Chroma Bait") then
                baitId = 6
            elseif Value:find("Dark Matter Bait") then
                baitId = 8
            elseif Value:find("Corrupt Bait") then
                baitId = 15
            end
            
            if baitId then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyBait = net:FindFirstChild("RF/PurchaseBait")
                        if buyBait then
                            buyBait:InvokeServer(baitId)
                        else
                            warn("PurchaseBait not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Bait purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyBait:SetValue("Select Bait...")
                end)
            end
        end
    })
    
end
do
    local settingTab = Tabs.Settings
    
    -- FPS Boost Section
    settingTab:AddSection("Performance")
    
    local fpsBoostButton = settingTab:AddButton({
        Title = "FPS Boost",
        Description = "Boost performance by disabling graphics effects",
        Callback = function()
            local success, error = pcall(function()
                game.Lighting.GlobalShadows = false
                settings().Rendering.QualityLevel = Enum.QualityLevel.Level03
                
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Enabled = false
                    end
                end
                
                for _, effect in pairs(game.Lighting:GetChildren()) do
                    if effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") 
                    or effect:IsA("DepthOfFieldEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = false
                    end
                end
            end)
            
            if not success then
                warn("FPS Boost error: " .. tostring(error))
            end
        end
    })
    
    local resetFpsButton = settingTab:AddButton({
        Title = "Reset FPS Boost",
        Description = "Restore original graphics settings",
        Callback = function()
            local success, error = pcall(function()
                game.Lighting.GlobalShadows = true
                settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
                
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Enabled = true
                    end
                end
                
                for _, effect in pairs(game.Lighting:GetChildren()) do
                    if effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") 
                    or effect:IsA("DepthOfFieldEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = true
                    end
                end
            end)
            if not success then
                warn("Reset FPS Boost error: " .. tostring(error))
            end
        end
    })
        local clearConfigButton = settingTab:AddButton({
        Title = "Clear Config",
        Description = "Remove Settings",
        Callback = function()
            local filePath = AutoConfig:GetFilePath()
            if isfile(filePath) then
                local success, err = pcall(function()
                    delfile(filePath)
                end)
                if success then
                    Fluent:Notify({
                        Title = "Settings",
                        Content = "Success.",
                        Duration = 5
                    })
                else
                    Fluent:Notify({
                        Title = "Settings",
                        Content = "Error",
                        Duration = 5
                    })
                end
            else
                Fluent:Notify({
                    Title = "Settings",
                    Content = "No configuration found.",
                    Duration = 5
                })
            end
        end
    })
    settingTab:AddSection("Server Management")
    local rejoinButton = settingTab:AddButton({
        Title = "Rejoin Server",
        Description = "Rejoin the current server",
        Callback = function()
            local player = game.Players.LocalPlayer
            local TeleportService = game:GetService("TeleportService")
            
            local success, err = pcall(function()
                TeleportService:Teleport(game.PlaceId, player)
            end)
            
            if not success then
                warn("Rejoin failed: " .. tostring(err))
            end
        end
    })
    local isAutoReconnectActive = false
    local reconnectAttempts = 0
    local maxReconnectAttempts = 3
    local reconnectData = {
        PlaceId = game.PlaceId,
        JobId = game.JobId or "",
        ServerInfo = game.JobId and game.JobId ~= "" and "Same Server" or "Random Server"
    }
    local function attemptReconnect()
        if not isAutoReconnectActive then return end
        reconnectAttempts = reconnectAttempts + 1
        local TeleportService = game:GetService("TeleportService")
        
        if reconnectAttempts <= 2 and reconnectData.JobId ~= "" then
            local success = pcall(function()
                TeleportService:TeleportToPlaceInstance(
                    reconnectData.PlaceId,
                    reconnectData.JobId,
                    game.Players.LocalPlayer
                )
            end)
            if success then
                return true
            end
        end
        if reconnectAttempts >= 2 or reconnectData.JobId == "" then
            local success = pcall(function()
                TeleportService:Teleport(reconnectData.PlaceId, game.Players.LocalPlayer)
            end)
            if success then
                return true
            end
        end
        if reconnectAttempts >= maxReconnectAttempts then
            reconnectAttempts = 0
            wait(10) 
        end
        return false
    end
    local autoReconnectToggle = settingTab:AddToggle("AutoReconnect", {
        Title = "Auto Reconnect",
        Description = "Automatically reconnect when disconnected",
        Default = false,
        Callback = function(Value)
            isAutoReconnectActive = Value
            reconnectAttempts = 0
            
            if Value then
                local serverType = reconnectData.JobId ~= "" and "Same Server First" or "Random Server"
            end
        end
    })
    spawn(function()
        local failCount = 0
        while wait(2) do
            if isAutoReconnectActive then
                local success = pcall(function()
                    local _ = game.Players.LocalPlayer.Character
                    local _ = game.Players.LocalPlayer.UserId
                    local _ = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                end)
                if not success then
                    failCount = failCount + 1
                    if failCount >= 3 then
                        for i = 1, 3 do
                            wait(3)
                            if attemptReconnect() then
                                break
                            end
                            wait(2)
                        end
                        failCount = 0
                    end
                else
                    failCount = 0
                end
            end
        end
    end)
    local function onErrorMessage()
        if not isAutoReconnectActive then return end
        wait(2) 
        spawn(function()
            for i = 1, 3 do
                if attemptReconnect() then
                    break
                end
                wait(3)
            end
        end)
    end
    pcall(function()
        game:GetService("GuiService").ErrorMessageChanged:Connect(function(msg)
            if isAutoReconnectActive and msg and msg ~= "" then
                if string.find(string.lower(msg), "disconnected") or 
                   string.find(string.lower(msg), "connection") or
                   string.find(string.lower(msg), "lost") or
                   string.find(string.lower(msg), "kick") then
                    onErrorMessage()
                end
            end
        end)
    end)
    pcall(function()
        game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
            if not isAutoReconnectActive then return end
            wait(0.5)
            if child.Name == "ErrorPrompt" then
                local reconnectButton = nil
                for _, desc in ipairs(child:GetDescendants()) do
                    if desc:IsA("TextButton") or desc:IsA("ImageButton") then
                        local text = desc.Text or ""
                        if string.find(string.lower(text), "reconnect") or 
                           string.find(string.lower(text), "retry") or
                           string.find(string.lower(text), "join") then
                            reconnectButton = desc
                            break
                        end
                    end
                end
                if reconnectButton then
                    pcall(function()
                        for i = 1, 3 do
                            firesignal(reconnectButton.MouseButton1Click)
                            firesignal(reconnectButton.Activated)
                            wait(0.5)
                        end
                    end)
                else
                    wait(2)
                    attemptReconnect()
                end
            end
        end)
    end)
    game.Players.LocalPlayer.OnTeleport:Connect(function(state)
        if not isAutoReconnectActive then return end
        if state == Enum.TeleportState.Failed then
            wait(3)
            attemptReconnect()
        end
    end)
    game.Players.PlayerRemoving:Connect(function(player)
        if player == game.Players.LocalPlayer and isAutoReconnectActive then
            attemptReconnect()
        end
    end)
    spawn(function()
        local RunService = game:GetService("RunService")
        local lastHeartbeat = tick()
        local timeout = 15 
        RunService.Heartbeat:Connect(function()
            lastHeartbeat = tick()
        end)
        while wait(5) do
            if isAutoReconnectActive then
                local timeSinceHeartbeat = tick() - lastHeartbeat
                if timeSinceHeartbeat > timeout then
                    lastHeartbeat = tick()
                    spawn(function()
                        attemptReconnect()
                    end)
                    wait(20) 
                end
            end
        end
    end)
    _G.ReconnectSameServer = function()
        if reconnectData.JobId ~= "" then
            game:GetService("TeleportService"):TeleportToPlaceInstance(
                reconnectData.PlaceId,
                reconnectData.JobId,
                game.Players.LocalPlayer
            )
        end
    end
    _G.ReconnectRandomServer = function()
        game:GetService("TeleportService"):Teleport(
            reconnectData.PlaceId,
            game.Players.LocalPlayer
        )
    end
    settingTab:AddSection("Server Information")
    local serverType = reconnectData.JobId ~= "" and "Private/VIP Server" or "Public Server"
    local playerCount = #game.Players:GetPlayers()
    local serverInfoParagraph = settingTab:AddParagraph({
        Title = "Current Server Details",
        Content = string.format("Server Type: %s\nPlayers Online: %d\nPlace ID: %d\nJob ID: %s", 
            serverType, 
            playerCount, 
            game.PlaceId,
            reconnectData.JobId ~= "" and reconnectData.JobId or "N/A"
        )
    })
    spawn(function()
        while wait(5) do
            local currentPlayers = #game.Players:GetPlayers()
            if currentPlayers ~= playerCount then
                playerCount = currentPlayers
                serverInfoParagraph:Set({
                    Title = "Server Details",
                    Content = string.format("Server Type: %s\nPlayers Online: %d\nPlace ID: %d\nJob ID: %s", 
                        serverType, 
                        playerCount, 
                        game.PlaceId,
                        reconnectData.JobId ~= "" and reconnectData.JobId or "N/A"
                    )
                })
            end
        end
    end)
end
do
    local webhookTab = Tabs.Webhook
    local webhookURL = ""
    local isWebhookActive = false
    local trackAllFish = true
    local minimumTier = 1
    local lastInventorySnapshot = {}
    local webhookCooldown = 1
    local lastWebhookTime = 0
    local monitoringStartTime = 0
    
    webhookTab:AddSection("Webhook Configuration")
    
    local webhookInput = webhookTab:AddInput("WebhookURL", {
        Title = "Discord Webhook URL",
        Description = "Paste your Discord webhook URL here",
        Default = "",
        Placeholder = "https://discord.com/api/webhooks/...",
        Numeric = false,
        Finished = false,
        Callback = function(Value)
            webhookURL = Value
            print("[DEBUG] Webhook URL set:", Value ~= "" and "URL_SET" or "URL_EMPTY")
        end
    })
    
    local tierSlider = webhookTab:AddSlider("MinimumTier", {
        Title = "Minimum Tier",
        Description = "Only track fish of this tier or higher",
        Default = 1,
        Min = 1,
        Max = 7,
        Rounding = 0,
        Callback = function(Value)
            minimumTier = Value
            print("[DEBUG] Minimum tier set to:", Value)
        end
    })
    
    -- Enhanced function to get item data with better error handling
    local function getItemData(itemId)
        print("[DEBUG] Getting item data for ID:", itemId)
        
        local success, result = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
            
            -- Try different methods to get fish data
            local itemData = nil
            
            -- Method 1: GetItemDataFromItemType for Fishes
            itemData = ItemUtility.GetItemDataFromItemType("Fishes", itemId)
            if itemData and itemData.Data then
                print("[DEBUG] Method 1 success - Fish:", itemData.Data.Name)
                return {
                    Name = itemData.Data.Name,
                    Type = itemData.Data.Type,
                    Tier = itemData.Data.Tier or 1,
                    SellPrice = itemData.SellPrice or 0,
                    Weight = itemData.Weight,
                    Icon = itemData.Data.Icon,
                    Probability = itemData.Probability
                }
            end
            
            -- Method 2: GetItemData
            itemData = ItemUtility:GetItemData(itemId)
            if itemData and itemData.Data then
                print("[DEBUG] Method 2 success - Item:", itemData.Data.Name, "Type:", itemData.Data.Type)
                return {
                    Name = itemData.Data.Name,
                    Type = itemData.Data.Type,
                    Tier = itemData.Data.Tier or 1,
                    SellPrice = itemData.SellPrice or 0,
                    Weight = itemData.Weight,
                    Icon = itemData.Data.Icon,
                    Probability = itemData.Probability
                }
            end
            
            -- Method 3: Try to find fish data by ID directly
            local fishesFolder = ReplicatedStorage:FindFirstChild("Shared")
            if fishesFolder then
                fishesFolder = fishesFolder:FindFirstChild("Fishes")
                if fishesFolder then
                    for _, fishScript in pairs(fishesFolder:GetChildren()) do
                        if fishScript:IsA("ModuleScript") then
                            local success2, fishData = pcall(require, fishScript)
                            if success2 and fishData and fishData.Data and fishData.Data.Id == itemId then
                                print("[DEBUG] Method 3 success - Direct fish:", fishData.Data.Name)
                                return {
                                    Name = fishData.Data.Name,
                                    Type = fishData.Data.Type,
                                    Tier = fishData.Data.Tier or 1,
                                    SellPrice = fishData.SellPrice or 0,
                                    Weight = fishData.Weight,
                                    Icon = fishData.Data.Icon,
                                    Probability = fishData.Probability
                                }
                            end
                        end
                    end
                end
            end
            
            print("[DEBUG] All methods failed for ID:", itemId)
            return nil
        end)
        
        if success then
            print("[DEBUG] Item data retrieval successful")
            return result
        else
            print("[DEBUG] Item data retrieval error:", result)
            return nil
        end
    end
    
    local function formatWeight(weight, actualWeight)
        if not actualWeight then
            return "Unknown"
        end
        local weightText = string.format("%.2f kg", actualWeight)
        if weight and weight.Big and actualWeight >= weight.Big.Min then
            weightText = weightText .. " 🏆 (BIG)"
        end
        return weightText
    end
    
    local function getTierInfo(tier)
        local tierColors = {
            [1] = {name = "Common", color = 0x808080, emoji = "⚪"},
            [2] = {name = "Uncommon", color = 0x00FF00, emoji = "🟢"},
            [3] = {name = "Rare", color = 0x0080FF, emoji = "🔵"},
            [4] = {name = "Epic", color = 0x8000FF, emoji = "🟣"},
            [5] = {name = "Legendary", color = 0xFF8000, emoji = "🟠"},
            [6] = {name = "Mythic", color = 0xFF0080, emoji = "🔴"},
            [7] = {name = "Secret", color = 0xFFD700, emoji = "⭐"},
            [8] = {name = "Exotic", color = 0xFF69B4, emoji = "💎"}
        }
        return tierColors[tier] or {name = "Unknown", color = 0x808080, emoji = "❓"}
    end
    
    local function sendWebhook(itemName, itemData, weight, isVariant, variantName)
        print("[DEBUG] Attempting to send webhook for:", itemName)
        
        if webhookURL == "" then
            print("[DEBUG] Webhook failed: URL is empty")
            return
        end
        
        -- Check cooldown
        local currentTime = tick()
        if currentTime - lastWebhookTime < webhookCooldown then
            print("[DEBUG] Webhook skipped: Cooldown active")
            return
        end
        lastWebhookTime = currentTime
        
        print("[DEBUG] Sending webhook...")
        
        spawn(function()
            local success, error = pcall(function()
                local player = game.Players.LocalPlayer
                local tierInfo = getTierInfo(itemData.Tier or 1)
                
                print("[DEBUG] Player:", player.Name)
                print("[DEBUG] Fish tier:", itemData.Tier, "Tier info:", tierInfo.name)
                
                local rarityText = "Unknown"
                if itemData.Probability and itemData.Probability.Chance then
                    local chance = itemData.Probability.Chance
                    if chance > 0 then
                        rarityText = string.format("1 in %.0f", 1/chance)
                    end
                end
                
                local fullItemName = itemName
                if isVariant and variantName then
                    fullItemName = "✨ " .. variantName .. " " .. itemName
                    print("[DEBUG] Variant fish detected:", fullItemName)
                end
                
                local totalValue = ""
                if weight and itemData.SellPrice then
                    local value = math.floor(itemData.SellPrice * (weight or 1))
                    totalValue = "\n**💵 Total Value:** $" .. tostring(value)
                    print("[DEBUG] Calculated value:", value)
                end
                
                -- Enhanced embed with more fish details
                local embedData = {
                    title = tierInfo.emoji .. " Fish Caught - " .. fullItemName,
                    color = tierInfo.color,
                    fields = {
                        {
                            name = "👤 **Player Info**",
                            value = "**Username:** " .. player.Name .. "\n**User ID:** " .. tostring(player.UserId),
                            inline = false
                        },
                        {
                            name = "🐟 **Fish Details**",
                            value = "**Name:** " .. fullItemName .. 
                                  "\n**Tier:** " .. tierInfo.name .. " (T" .. (itemData.Tier or 1) .. ")" ..
                                  "\n**Rarity:** " .. rarityText,
                            inline = true
                        },
                        {
                            name = "📊 **Stats**",
                            value = "**Weight:** " .. formatWeight(itemData.Weight, weight) ..
                                  "\n**Base Price:** $" .. tostring(itemData.SellPrice or 0) ..
                                  totalValue,
                            inline = true
                        }
                    },
                    timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                    footer = {
                        text = "Fish It Webhook • Tier " .. (minimumTier or 1) .. "+ Only"
                    }
                }
                
                local webhookData = {
                    username = "Fish It Bot",
                    embeds = {embedData}
                }
                
                local headers = {["Content-Type"] = "application/json"}
                local body = game:GetService("HttpService"):JSONEncode(webhookData)
                
                print("[DEBUG] Webhook payload size:", #body, "characters")
                
                local req = http_request or request or syn.request
                if fluxus and fluxus.request then
                    req = fluxus.request
                end
                
                if req then
                    print("[DEBUG] Sending HTTP request...")
                    local response = req({
                        Url = webhookURL,
                        Method = "POST",
                        Headers = headers,
                        Body = body
                    })
                    print("[DEBUG] Webhook response:", response and response.StatusCode or "NO_RESPONSE")
                else
                    print("[DEBUG] No HTTP request function available")
                end
            end)
            
            if success then
                print("[DEBUG] Webhook sent successfully!")
            else
                print("[DEBUG] Webhook error:", error)
                warn("Webhook error:", error)
            end
        end)
    end
    
    local inventoryConnection = nil
    
    local function startWebhookMonitoring()
    print("[DEBUG] Starting webhook monitoring...")
    print("[DEBUG] Webhook URL:", webhookURL ~= "" and "SET" or "EMPTY")
    print("[DEBUG] Minimum tier:", minimumTier)

    local success = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local InventoryController = require(ReplicatedStorage.Controllers.InventoryController)

        if not InventoryController then
            error("Failed to require InventoryController")
        end

        print("[DEBUG] Connected to InventoryController successfully")

        -- Set monitoring start time BEFORE taking snapshot
        monitoringStartTime = tick()
        print("[DEBUG] Monitoring start time set:", monitoringStartTime)

        -- Clear snapshot dulu
        lastInventorySnapshot = {}

        -- Listener InventoryStateChanged
        inventoryConnection = InventoryController.InventoryStateChanged:Connect(function(category)
            print("[DEBUG] InventoryStateChanged fired:", category)

            -- hanya proses kalau kategori ikan
            if category ~= "Fish" and category ~= "Fishes" then
                print("[DEBUG] Category bukan ikan, skip:", category)
                return
            end

            local inventory = InventoryController.Inventory
            if not inventory then
                print("[DEBUG] Tidak ada data inventory di controller")
                return
            end

            local newItemsFound = 0
            local fishFound = 0
            local currentTime = tick()

            for uuid, itemData in pairs(inventory or {}) do
                if not lastInventorySnapshot[uuid] and (currentTime - monitoringStartTime) > 2 then
                    newItemsFound += 1
                    print("[DEBUG] Fish item baru UUID:", uuid)

                    if itemData and itemData.Id then
                        local itemInfo = getItemData(itemData.Id)
                        if itemInfo and itemInfo.Type == "Fishes" then
                            fishFound += 1
                            print("[DEBUG] Fish baru ditemukan:", itemInfo.Name, "Tier:", itemInfo.Tier)

                            if itemInfo.Tier >= minimumTier then
                                local weight = itemData.Metadata and itemData.Metadata.Weight
                                local isVariant, variantName = false, nil
                                if itemData.Metadata and itemData.Metadata.VariantId then
                                    local ok, variantData = pcall(function()
                                        local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
                                        return ItemUtility:GetVariantData(itemData.Metadata.VariantId)
                                    end)
                                    if ok and variantData and variantData.Data then
                                        isVariant, variantName = true, variantData.Data.Name
                                        print("[DEBUG] Variant:", variantName)
                                    end
                                end
                                sendWebhook(itemInfo.Name, itemInfo, weight, isVariant, variantName)
                            else
                                print("[DEBUG] Fish tier terlalu rendah:", itemInfo.Tier, "<", minimumTier)
                            end
                        else
                            print("[DEBUG] Item bukan fish atau gagal dapat info")
                        end
                    else
                        print("[DEBUG] Item data kosong atau tidak ada Id")
                    end

                    lastInventorySnapshot[uuid] = true
                end
            end

            print("[DEBUG] Summary (InventoryStateChanged) - New:", newItemsFound, "Fish:", fishFound)
        end)

        print("[DEBUG] Webhook monitoring started successfully!")
    end)

    if not success then
        print("[DEBUG] Failed to start webhook monitoring")
        return false
    end

    return true
end

    
    local function stopWebhookMonitoring()
        print("[DEBUG] Stopping webhook monitoring...")
        if inventoryConnection then
            inventoryConnection:Disconnect()
            inventoryConnection = nil
            print("[DEBUG] Inventory connection disconnected")
        end
        lastInventorySnapshot = {}
        monitoringStartTime = 0
        print("[DEBUG] Inventory snapshot cleared")
    end
    
    webhookTab:AddSection("Webhook Controls")
    
    local webhookToggle = webhookTab:AddToggle("WebhookToggle", {
        Title = "Enable Webhook",
        Description = "Start tracking all fish catches",
        Default = false,
        Callback = function(Value)
            if Value then
                if webhookURL == "" or not string.find(webhookURL, "discord.com/api/webhooks") then
                    Fluent:Notify({
                        Title = "Webhook Error",
                        Content = "Please enter a valid Discord webhook URL first!",
                        Duration = 5
                    })
                    Options.WebhookToggle:SetValue(false)
                    return
                end
                
                print("[DEBUG] Enabling webhook with URL:", webhookURL)
                
                if startWebhookMonitoring() then
                    isWebhookActive = true
                    Fluent:Notify({
                        Title = "Webhook Active",
                        Content = "Now tracking ALL fish catches (Tier " .. minimumTier .. "+)!\nWait 3 seconds before fishing...",
                        Duration = 5
                    })
                    print("[DEBUG] Webhook monitoring enabled successfully")
                else
                    Fluent:Notify({
                        Title = "Webhook Error",
                        Content = "Failed to start monitoring. Try rejoining.",
                        Duration = 5
                    })
                    Options.WebhookToggle:SetValue(false)
                    print("[DEBUG] Failed to enable webhook monitoring")
                end
            else
                isWebhookActive = false
                stopWebhookMonitoring()
                Fluent:Notify({
                    Title = "Webhook Disabled",
                    Content = "Stopped tracking fish catches.",
                    Duration = 3
                })
                print("[DEBUG] Webhook monitoring disabled")
            end
        end
    })
    
    local testWebhookButton = webhookTab:AddButton({
        Title = "Test Webhook",
        Description = "Send a test message to verify webhook",
        Callback = function()
            if webhookURL == "" or not string.find(webhookURL, "discord.com/api/webhooks") then
                Fluent:Notify({
                    Title = "Test Failed",
                    Content = "Please enter a valid webhook URL first!",
                    Duration = 5
                })
                return
            end
            
            print("[DEBUG] Sending test webhook...")
            
            local testData = {
                Name = "Test Fish",
                Type = "Fishes",
                Tier = 7,
                SellPrice = 150000,
                Weight = {Default = {Min = 2, Max = 5}, Big = {Min = 4}},
                Probability = {Chance = 0.000001}
            }
            
            sendWebhook("Test Fish", testData, 4.2, true, "Shiny")
            
            Fluent:Notify({
                Title = "Test Sent",
                Content = "Check your Discord channel!",
                Duration = 3
            })
        end
    })
    
    -- Alternative monitoring method button
    local altMonitorButton = webhookTab:AddButton({
        Title = "Alternative Monitor",
        Description = "Try alternative fish detection method",
        Callback = function()
            if not isWebhookActive then
                Fluent:Notify({
                    Title = "Webhook Not Active",
                    Content = "Please enable webhook first!",
                    Duration = 3
                })
                return
            end
            
            print("[DEBUG] Starting alternative monitoring...")
            
            -- Alternative method: Monitor inventory size changes
            spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Client = require(ReplicatedStorage.Packages.Replion).Client
                local dataReplion = Client:WaitReplion("Data")
                
                if dataReplion then
                    local lastInventorySize = 0
                    local currentInventory = dataReplion:Get("Inventory") or {}
                    for _ in pairs(currentInventory) do
                        lastInventorySize = lastInventorySize + 1
                    end
                    
                    print("[DEBUG] Alternative method - Initial inventory size:", lastInventorySize)
                    
                    local altConnection = dataReplion:OnChange("Inventory", function(newValue)
                        if type(newValue) == "table" then
                            local newSize = 0
                            for _ in pairs(newValue) do
                                newSize = newSize + 1
                            end
                            
                            if newSize > lastInventorySize then
                                print("[DEBUG] ALT METHOD: Inventory size increased from", lastInventorySize, "to", newSize)
                                
                                -- Find the newest item (likely the last one added)
                                local newestItem = nil
                                local newestUUID = nil
                                
                                for uuid, item in pairs(newValue) do
                                    if not lastInventorySnapshot[uuid] then
                                        newestItem = item
                                        newestUUID = uuid
                                        break
                                    end
                                end
                                
                                if newestItem and newestItem.Id then
                                    print("[DEBUG] ALT METHOD: Processing newest item:", newestItem.Id)
                                    local itemInfo = getItemData(newestItem.Id)
                                    
                                    if itemInfo and itemInfo.Type == "Fishes" and itemInfo.Tier >= minimumTier then
                                        print("[DEBUG] ALT METHOD: Sending webhook for fish:", itemInfo.Name)
                                        
                                        local weight = newestItem.Metadata and newestItem.Metadata.Weight
                                        local isVariant = false
                                        local variantName = nil
                                        
                                        if newestItem.Metadata and newestItem.Metadata.VariantId then
                                            local variantSuccess, variantData = pcall(function()
                                                local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
                                                return ItemUtility:GetVariantData(newestItem.Metadata.VariantId)
                                            end)
                                            
                                            if variantSuccess and variantData and variantData.Data then
                                                isVariant = true
                                                variantName = variantData.Data.Name
                                            end
                                        end
                                        
                                        sendWebhook(itemInfo.Name, itemInfo, weight, isVariant, variantName)
                                        lastInventorySnapshot[newestUUID] = true
                                    end
                                end
                            end
                            
                            lastInventorySize = newSize
                        end
                    end)
                    
                    -- Clean up connection after 60 seconds
                    task.delay(60, function()
                        if altConnection then
                            altConnection:Disconnect()
                            print("[DEBUG] Alternative monitoring stopped after 60 seconds")
                        end
                    end)
                end
            end)
        end
    })
    
    -- Debug button to check current inventory
    local debugButton = webhookTab:AddButton({
        Title = "Debug Inventory",
        Description = "Print current inventory state",
        Callback = function()
            local success, result = pcall(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Client = require(ReplicatedStorage.Packages.Replion).Client
                local dataReplion = Client:WaitReplion("Data")
                
                if dataReplion then
                    local inventory = dataReplion:Get("Inventory") or {}
                    local count = 0
                    print("[DEBUG] === CURRENT INVENTORY ===")
                    for uuid, item in pairs(inventory) do
                        count = count + 1
                        print("[DEBUG] Item", count, "- UUID:", uuid, "ID:", item.Id or "NO_ID")
                        if item.Id then
                            local itemInfo = getItemData(item.Id)
                            if itemInfo then
                                print("[DEBUG]   Name:", itemInfo.Name, "Type:", itemInfo.Type, "Tier:", itemInfo.Tier)
                            end
                        end
                        if item.Metadata then
                            if item.Metadata.Weight then
                                print("[DEBUG]   Weight:", item.Metadata.Weight)
                            end
                            if item.Metadata.VariantId then
                                print("[DEBUG]   Variant:", item.Metadata.VariantId)
                            end
                        end
                        print("[DEBUG]   In snapshot:", lastInventorySnapshot[uuid] and "YES" or "NO")
                    end
                    print("[DEBUG] Total inventory items:", count)
                    
                    local snapshotCount = 0
                    for _ in pairs(lastInventorySnapshot) do
                        snapshotCount = snapshotCount + 1
                    end
                    print("[DEBUG] Snapshot items:", snapshotCount)
                    print("[DEBUG] Monitoring time:", tick() - monitoringStartTime, "seconds")
                else
                    print("[DEBUG] Failed to get data replion")
                end
            end)
            
            if not success then
                print("[DEBUG] Debug inventory error:", result)
            end
        end
    })
    
    webhookTab:AddSection("Information")
    
    webhookTab:AddParagraph({
        Title = "How It Works",
        Content = "This webhook tracks ALL fish you catch and sends detailed notifications to Discord. Wait 3 seconds after enabling before fishing. Use the tier slider to filter out common fish."
    })
    
    webhookTab:AddParagraph({
        Title = "Troubleshooting",
        Content = "1. Enable webhook\n2. Wait 3 seconds\n3. Start fishing\n4. Check console (F9) for debug\n5. Try 'Alternative Monitor' if normal method fails"
    })
    
    webhookTab:AddParagraph({
        Title = "Fish Info Included",
        Content = "• Fish name (with variant if applicable)\n• Tier name and number with color coding\n• Weight with BIG indicator\n• Rarity (1 in X chance)\n• Base price and calculated total value\n• Player username and ID"
    })
end
end
Window:SelectTab(1)
AutoConfig:Initialize(Fluent)
